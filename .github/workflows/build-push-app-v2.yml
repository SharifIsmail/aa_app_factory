name: Build & Push Service Images for Extensibility Apps (v2 - Composite Actions)

# NOTE: Variable & Secret Sources:
# 
# Repository-level Variables (Settings ‚Üí Secrets and variables ‚Üí Actions ‚Üí Variables):
#   - IMAGE_REGISTRY       
#   - JFROG_REGISTRY
#   - JFROG_REGISTRY_PARTNERS
#
# Repository-level Secrets (Settings ‚Üí Secrets and variables ‚Üí Actions ‚Üí Repository secrets):
#   - IMAGE_REGISTRY_USER
#   - IMAGE_REGISTRY_PASSWORD
#   - JFROG_REGISTRY_USER
#   - JFROG_REGISTRY_PASSWORD
#
# c-prod(dev) Environment Variables (Settings ‚Üí Environments ‚Üí c-prod(dev) ‚Üí Variables):
#   - SERVICE_PHARIA_KERNEL_URL
#   - PHARIA_AUTH_SERVICE_URL
#   - PHARIA_IAM_ISSUER_URL
#   - PHARIA_DATA_URL
#   - SERVICE_INFERENCE_API_URL
#   - SERVICE_COMPLETION_MODEL_NAME
#
# c-prod(dev) Environment Secrets (Settings ‚Üí Environments ‚Üí c-prod(dev) ‚Üí Secrets):
#   - SERVICE_AUTHENTICATION_TOKEN
#   - SERPER_API_KEY
#   - ABSTRACT_API_KEY

on:
  push:
    branches:
      - main
      - 'release/**'
    paths:
      - 'apps/**'
  create:
  pull_request:
    branches:
      - main
      - 'release/**'
    paths:
      - 'apps/**'
  # Allow manual triggering
  workflow_dispatch:
    inputs:
      app_name:
        description: 'Micro-app to build and push'
        required: true
        type: choice
        options:
          - supplier_analysis
          - law_monitoring
          - agentic_app_template
          - supplier_briefing
      force_build:
        description: 'Force build even if no changes detected'
        required: false
        type: boolean
        default: true

jobs:
  # Detect which micro-apps have changed
  detect-changes:
    if: github.event_name != 'create' || (github.event.ref_type == 'branch' && startsWith(github.event.ref, 'release/'))
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
    outputs:
      affected_apps: ${{ steps.set-apps.outputs.affected_apps }}
      release_version: ${{ steps.validate-release.outputs.RELEASE_VERSION }}
      release_label: ${{ steps.validate-release.outputs.RELEASE_LABEL }}
      release_version_tag: ${{ steps.validate-release.outputs.RELEASE_VERSION_TAG }}
      app_from_branch: ${{ steps.validate-release.outputs.APP_NAME }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for detecting changes

      - name: Validate release branch name
        id: validate-release
        if: startsWith(github.ref, 'refs/heads/release/') || (github.event_name == 'create' && github.event.ref_type == 'branch' && startsWith(github.event.ref, 'release/'))
        run: |
          BRANCH_NAME="${{ github.ref_name }}"
          if [ -z "$BRANCH_NAME" ]; then BRANCH_NAME="${{ github.event.ref }}"; fi
          echo "Parsing release metadata from branch: $BRANCH_NAME"
          
          # Allow optional label(s) after the date, e.g. release/<app>-YYYY-MM-DD-beta-explainability
          if [[ "$BRANCH_NAME" =~ ^release\/([a-z0-9_\-]+)-([0-9]{4}-[0-9]{2}-[0-9]{2})(-(.+))?$ ]]; then
            APP_NAME="${BASH_REMATCH[1]}"
            VERSION_DATE="${BASH_REMATCH[2]}"
            LABEL_SUFFIX="${BASH_REMATCH[4]}"  # may be empty

            # Build YYMMDD tag from YYYY-MM-DD
            VERSION_DATE_YYMMDD=$(echo "$VERSION_DATE" | sed -E 's/^[0-9]{2}([0-9]{2})-([0-9]{2})-([0-9]{2})/\1\2\3/')
            if [ -n "$LABEL_SUFFIX" ]; then
              RELEASE_VERSION_TAG="${VERSION_DATE_YYMMDD}-${LABEL_SUFFIX}"
            else
              RELEASE_VERSION_TAG="${VERSION_DATE_YYMMDD}"
            fi

            echo "Valid release branch name: app=$APP_NAME date=$VERSION_DATE label=${LABEL_SUFFIX:-none} tag=$RELEASE_VERSION_TAG"
            echo "APP_NAME=${APP_NAME}" >> $GITHUB_OUTPUT
            echo "RELEASE_VERSION=${VERSION_DATE}" >> $GITHUB_OUTPUT
            echo "RELEASE_LABEL=${LABEL_SUFFIX}" >> $GITHUB_OUTPUT
            echo "RELEASE_VERSION_TAG=${RELEASE_VERSION_TAG}" >> $GITHUB_OUTPUT
          else
            echo "::error::Invalid release branch name format. Expected: release/<app-name>-YYYY-MM-DD[-<label>]"
            exit 1
          fi

      - name: Detect changed files
        id: changed-files
        uses: tj-actions/changed-files@ed68ef82c095e0d48ec87eccea555d944a631a4c # pinned to v46 commit
        with:
          files: apps/**
          dir_names: true
          dir_names_max_depth: 2
          json: true

      - name: Set affected apps
        id: set-apps
        run: |
          FORCE_BUILD="${{ github.event.inputs.force_build || 'false' }}"
          
          # Priority 1: Manual trigger (workflow_dispatch)
          if [[ "$FORCE_BUILD" == "true" ]]; then
            APP_NAME="${{ github.event.inputs.app_name }}"
            echo "affected_apps=[\"$APP_NAME\"]" >> $GITHUB_OUTPUT
            echo "::notice::Forcing build for app: $APP_NAME"
          
          # Priority 2: Release branch - reuse validated app name from validate-release step
          elif [[ -n "${{ steps.validate-release.outputs.APP_NAME }}" ]]; then
            DERIVED_APP="${{ steps.validate-release.outputs.APP_NAME }}"
            echo "Derived app from branch name: $DERIVED_APP"
            echo "affected_apps=[\"$DERIVED_APP\"]" >> $GITHUB_OUTPUT
          
          # Priority 3: File change detection
          else
            CHANGED_FILES='${{ steps.changed-files.outputs.all_changed_files }}'

            if [[ -z "$CHANGED_FILES" ]]; then
                APPS="[]"
            else
                APPS=$(echo "$CHANGED_FILES" | sed 's/\\"/"/g' | jq -c '[.[] | select(startswith("apps/")) | split("/")[1]] | unique')
            fi

            if [[ "$APPS" == "[]" || "$APPS" == "" ]]; then
              echo "::notice::No apps affected by changes."
              echo "affected_apps=[]" >> $GITHUB_OUTPUT
            else
              echo "::notice::Affected apps from changes: $APPS"
              echo "affected_apps=$APPS" >> $GITHUB_OUTPUT
            fi
          fi

  # Build, verify, and push the apps
  build-verify-push:
    name: üî® Build ${{ matrix.app }}
    needs: detect-changes
    if: needs.detect-changes.outputs.affected_apps != '[]' && needs.detect-changes.outputs.affected_apps != ''
    permissions:
      contents: read
    runs-on: ubuntu-latest
    environment: c-prod(dev)
    
    outputs:
      image_tag: ${{ steps.container.outputs.image_tag }}
      build_success: ${{ steps.container.outputs.success }}
      release_version: ${{ needs.detect-changes.outputs.release_version }}
    
    strategy:
      matrix:
        app: ${{ fromJson(needs.detect-changes.outputs.affected_apps) }}
      fail-fast: false

    env:
      APP_NAME: ${{ matrix.app }}
      BUILD_ENV: ${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üèóÔ∏è Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: lts/*

      - name: üìÇ Check app directory structure
        id: check-structure
        run: |
          echo "::group::Checking app structure"
          
          # Check if the app directory exists
          if [ ! -d "./apps/${{ matrix.app }}" ]; then
            echo "::error::App directory './apps/${{ matrix.app }}' not found"
            exit 1
          fi
          
          # Check for service directory
          if [ -d "./apps/${{ matrix.app }}/service" ]; then
            echo "service_dir=true" >> $GITHUB_OUTPUT
          else
            echo "service_dir=false" >> $GITHUB_OUTPUT
          fi

          # Find dockerfile
          if [ -f "./apps/${{ matrix.app }}/Containerfile" ]; then
            echo "dockerfile_path=./apps/${{ matrix.app }}/Containerfile" >> $GITHUB_OUTPUT
            echo "build_context=./apps/${{ matrix.app }}" >> $GITHUB_OUTPUT
          elif [ -f "./apps/${{ matrix.app }}/service/Containerfile" ]; then
            echo "dockerfile_path=./apps/${{ matrix.app }}/service/Containerfile" >> $GITHUB_OUTPUT
            echo "build_context=./apps/${{ matrix.app }}/service" >> $GITHUB_OUTPUT
          elif [ -f "./apps/${{ matrix.app }}/Dockerfile" ]; then
            echo "dockerfile_path=./apps/${{ matrix.app }}/Dockerfile" >> $GITHUB_OUTPUT
            echo "build_context=./apps/${{ matrix.app }}" >> $GITHUB_OUTPUT
          elif [ -f "./apps/${{ matrix.app }}/service/Dockerfile" ]; then
            echo "dockerfile_path=./apps/${{ matrix.app }}/service/Dockerfile" >> $GITHUB_OUTPUT
            echo "build_context=./apps/${{ matrix.app }}/service" >> $GITHUB_OUTPUT
          else
            echo "::error::No Containerfile or Dockerfile found for app ${{ matrix.app }}"
            exit 1
          fi
          
          echo "::notice::App structure validated"
          echo "::endgroup::"

      - name: üé® Build UI
        uses: ./.github/actions/build-ui
        with:
          app_name: ${{ matrix.app }}
          workspace_path: ${{ github.workspace }}

      - name: ‚öôÔ∏è Setup container environment
        uses: ./.github/actions/setup-container-env
        with:
          app_name: ${{ matrix.app }}
          build_context: ${{ steps.check-structure.outputs.build_context }}
          build_env: ${{ env.BUILD_ENV }}
          service_pharia_kernel_url: ${{ vars.SERVICE_PHARIA_KERNEL_URL }}
          service_pharia_auth_service_url: ${{ vars.PHARIA_AUTH_SERVICE_URL }}
          service_pharia_iam_issuer_url: ${{ vars.PHARIA_IAM_ISSUER_URL }}
          service_pharia_data_url: ${{ vars.PHARIA_DATA_URL }}
          service_inference_api_url: ${{ vars.SERVICE_INFERENCE_API_URL }}
          service_completion_model_name: ${{ vars.SERVICE_COMPLETION_MODEL_NAME }}
          service_authentication_token: ${{ secrets.SERVICE_AUTHENTICATION_TOKEN }}
          serper_api_key: ${{ secrets.SERPER_API_KEY }}
          abstract_api_key: ${{ secrets.ABSTRACT_API_KEY }}

      - name: üî® Build and verify container
        id: container
        uses: ./.github/actions/build-and-verify-container
        with:
          app_name: ${{ matrix.app }}
          dockerfile_path: ${{ steps.check-structure.outputs.dockerfile_path }}
          build_context: ${{ steps.check-structure.outputs.build_context }}
          workspace_path: ${{ github.workspace }}

      - name: üöÄ Push images
        id: push
        uses: ./.github/actions/push-images
        with:
          app_name: ${{ matrix.app }}
          image_tag: ${{ steps.container.outputs.image_tag }}
          branch_ref: ${{ github.ref }}
          image_registry: ${{ vars.IMAGE_REGISTRY }}
          jfrog_registry: ${{ vars.JFROG_REGISTRY }}
          jfrog_registry_partners: ${{ vars.JFROG_REGISTRY_PARTNERS }}
          image_registry_user: ${{ secrets.IMAGE_REGISTRY_USER }}
          image_registry_password: ${{ secrets.IMAGE_REGISTRY_PASSWORD }}
          jfrog_registry_user: ${{ secrets.JFROG_REGISTRY_USER }}
          jfrog_registry_password: ${{ secrets.JFROG_REGISTRY_PASSWORD }}
          release_version_tag: ${{ needs.detect-changes.outputs.release_version_tag }}

      - name: üìä Build summary
        if: always()
        run: |
          echo "::group::Build Summary"
          echo "### üî® Build Summary for ${{ matrix.app }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Application** | ${{ matrix.app }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Build Environment** | ${{ env.BUILD_ENV }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Image Tag** | ${{ steps.container.outputs.image_tag }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Branch** | ${{ github.ref_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Built By** | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Build Time** | $(date -u '+%Y-%m-%d %H:%M:%S UTC') |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Build status
          if [ "${{ steps.container.outputs.success }}" = "true" ]; then
            echo "‚úÖ **Build Status**: SUCCESS" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ **Container Verification**: PASSED" >> $GITHUB_STEP_SUMMARY
            if [ -n "${{ steps.push.outputs.gitlab_latest }}" ]; then
              echo "‚úÖ **GitLab Push**: SUCCESS" >> $GITHUB_STEP_SUMMARY
            fi
            if [ -n "${{ steps.push.outputs.jfrog_tags }}" ]; then
              echo "‚úÖ **JFrog Push**: SUCCESS (tags: ${{ steps.push.outputs.jfrog_tags }})" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "‚ùå **Build Status**: FAILED" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Release information
          if [[ "${{ github.ref }}" =~ ^refs/heads/release/ ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üöÄ Release Information" >> $GITHUB_STEP_SUMMARY
            echo "| **Release Version** | ${{ needs.detect-changes.outputs.release_version }} |" >> $GITHUB_STEP_SUMMARY
            echo "| **Release Tag** | ${{ needs.detect-changes.outputs.release_version_tag }} |" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "::endgroup::"

  summary:
    name: üìã Build Summary
    needs: [detect-changes, build-verify-push]
    if: always() && needs.detect-changes.outputs.affected_apps != '[]' && needs.detect-changes.outputs.affected_apps != ''
    permissions: {}
    runs-on: ubuntu-latest
    steps:
      - name: Generate overall summary
        run: |
          echo "## üèóÔ∏è Extensibility Apps Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Add build type and release information
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "**Build Type:** Main Branch Build" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ github.ref }}" =~ ^refs/heads/release/ ]]; then
            echo "**Build Type:** Release Build" >> $GITHUB_STEP_SUMMARY
            RELEASE_VERSION="${{ needs.detect-changes.outputs.release_version }}"
            RELEASE_VERSION_TAG="${{ needs.detect-changes.outputs.release_version_tag }}"
            if [[ -n "$RELEASE_VERSION_TAG" ]]; then
              echo "**Release Version Tag:** $RELEASE_VERSION_TAG" >> $GITHUB_STEP_SUMMARY
            fi
            if [[ -n "$RELEASE_VERSION" ]]; then
              echo "**Release Version (date):** $RELEASE_VERSION" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "**Build Type:** Development Build" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### üìä Build Status:" >> $GITHUB_STEP_SUMMARY
          
          # Get results from build job
          BUILD_RESULT="${{ needs.build-verify-push.result }}"
          AFFECTED_APPS='${{ needs.detect-changes.outputs.affected_apps }}'
          
          if [[ "$BUILD_RESULT" == "success" ]]; then
            echo "‚úÖ All apps built, verified, and pushed successfully" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå Some builds failed - check individual app results above" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîß Pipeline Steps:" >> $GITHUB_STEP_SUMMARY
          echo "1. üé® **Build UI**: Create frontend artifacts" >> $GITHUB_STEP_SUMMARY
          echo "2. ‚öôÔ∏è **Setup Environment**: Configure container environment" >> $GITHUB_STEP_SUMMARY
          echo "3. üî® **Build Container**: Create and verify container image" >> $GITHUB_STEP_SUMMARY
          echo "4. üöÄ **Push Images**: Publish to GitLab registry and JFrog registries (release branches only)" >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üì¶ Affected Apps:" >> $GITHUB_STEP_SUMMARY
          echo "$AFFECTED_APPS" | jq -r '.[]' | while read app; do
            echo "- **$app**" >> $GITHUB_STEP_SUMMARY
          done
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üè™ Registry Information:" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ github.ref }}" =~ ^refs/heads/release/ ]]; then
            echo "**‚úÖ GitLab Registry:** \`${{ vars.IMAGE_REGISTRY }}\` (tags: latest, ${VERSION_TAG}, release-latest)" >> $GITHUB_STEP_SUMMARY
            echo "**‚úÖ JFrog Customer Registry:** \`${{ vars.JFROG_REGISTRY }}\` (tags: latest, ${VERSION_TAG})" >> $GITHUB_STEP_SUMMARY
            echo "**‚úÖ JFrog Partner Registry:** \`${{ vars.JFROG_REGISTRY_PARTNERS }}\` (tags: latest, ${VERSION_TAG} - selected apps only)" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "**‚úÖ GitLab Registry:** \`${{ vars.IMAGE_REGISTRY }}\` (tags: latest, main_latest)" >> $GITHUB_STEP_SUMMARY
            echo "**‚ùå JFrog Registries:** Skipped (release branches only)" >> $GITHUB_STEP_SUMMARY
          else
            echo "**‚úÖ GitLab Registry:** \`${{ vars.IMAGE_REGISTRY }}\` (tags: latest)" >> $GITHUB_STEP_SUMMARY
            echo "**‚ùå JFrog Registries:** Skipped (release branches only)" >> $GITHUB_STEP_SUMMARY
          fi
